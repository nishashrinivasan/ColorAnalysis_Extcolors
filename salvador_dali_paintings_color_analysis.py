# -*- coding: utf-8 -*-
"""Optimized Salvador Dali Color Analysis.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1VPG10epMH1p_tLmX7nn2iKNcbvqHk8rC
"""

from google.colab import drive
drive.mount('/content/drive')

import os

# Adjust the path based on where you placed it inside your Drive
IMAGE_FOLDER = "/content/drive/MyDrive/Salvador_Dali_100"

!ls /content/drive/MyDrive/Salvador_Dali_100

!pip install opencv-python-headless scikit-learn webcolors seaborn pandas colormath

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.cluster import KMeans
from collections import Counter
import os
import cv2
from PIL import Image
try:
    import extcolors
except ImportError:
    print("Installing extcolors library...")
    !pip install extcolors
    import extcolors

# Define extended color dictionary for more precise color naming
CSS3_COLORS = {
    # Basic colors
    "black": (0, 0, 0),
    "silver": (192, 192, 192),
    "gray": (128, 128, 128),
    "white": (255, 255, 255),
    "maroon": (128, 0, 0),
    "red": (255, 0, 0),
    "purple": (128, 0, 128),
    "fuchsia": (255, 0, 255),
    "green": (0, 128, 0),
    "lime": (0, 255, 0),
    "olive": (128, 128, 0),
    "yellow": (255, 255, 0),
    "navy": (0, 0, 128),
    "blue": (0, 0, 255),
    "teal": (0, 128, 128),
    "aqua": (0, 255, 255),
    "orange": (255, 165, 0),
    "pink": (255, 192, 203),
    "gold": (255, 215, 0),
    "beige": (245, 245, 220),
    "brown": (165, 42, 42),
    "ivory": (255, 255, 240),
    "lavender": (230, 230, 250),
    # Extended artistic colors
    "ochre": (204, 119, 34),
    "sienna": (160, 82, 45),
    "umber": (99, 81, 71),
    "cream": (255, 253, 208),
    "khaki": (240, 230, 140),
    "tan": (210, 180, 140),
    "turquoise": (64, 224, 208),
    "crimson": (220, 20, 60),
    "vermilion": (227, 66, 52),
    "cerulean": (0, 123, 167),
    "cobalt": (0, 71, 171),
    "ultramarine": (18, 10, 143),
    "indigo": (75, 0, 130),
    "viridian": (64, 130, 109),
    "sap green": (80, 125, 42),
    "cadmium yellow": (255, 246, 0),
    "cadmium red": (227, 0, 34),
    "alizarin": (227, 38, 54),
    "magenta": (202, 31, 123),
    "prussian blue": (0, 49, 83),
    "burnt sienna": (233, 116, 81),
    "raw sienna": (193, 154, 107),
    "burnt umber": (138, 51, 36),
    "raw umber": (130, 102, 68),
    "titanium white": (252, 252, 252),
    "zinc white": (248, 248, 255),
    "paynes gray": (83, 104, 120),
    "vandyke brown": (102, 69, 40),
    "naples yellow": (250, 218, 94),
    "terre verte": (56, 94, 64),
    "sepia": (112, 66, 20),
    "amber": (255, 191, 0),
    "terracotta": (226, 114, 91),
    "burgundy": (128, 0, 32),
    "coral": (255, 127, 80),
    "salmon": (250, 128, 114),
    "peach": (255, 218, 185),
    "mustard": (255, 219, 88),
    "emerald": (80, 220, 100),
    "azure": (0, 127, 255),
    "midnight blue": (25, 25, 112),
    "periwinkle": (204, 204, 255),
    "lilac": (200, 162, 200),
    "mauve": (204, 153, 204)
}

# Install required packages
try:
    import cv2
    import sklearn
    import seaborn
    import pandas
    import numpy
except ImportError:
    print("Installing required packages...")
    !pip install opencv-python-headless scikit-learn webcolors seaborn pandas colormath
    !pip install extcolors

# Configuration
IMAGE_FOLDER = "/content/drive/MyDrive/Salvador_Dali_100"
N_COLORS = 5  # Increased for more detailed painting analysis
OUTPUT_CSV = "/content/drive/MyDrive/dali_paintings_color_data.csv"

def closest_color(rgb_tuple):
    """Find the closest color name for an RGB tuple (optimized)"""
    min_distance = float('inf')
    closest_name = "unknown"

    r, g, b = rgb_tuple

    for name, (r2, g2, b2) in CSS3_COLORS.items():
        # Faster than calculating squares
        distance = abs(r - r2) + abs(g - g2) + abs(b - b2)

        if distance < min_distance:
            min_distance = distance
            closest_name = name

    return closest_name

def get_colors_with_extcolors(image_path, n_colors=N_COLORS):
    """Extract dominant colors using extcolors library (optimized)"""
    try:
        # Open image with PIL and resize for faster processing
        img = Image.open(image_path).convert("RGB")

        # Resize to smaller dimensions for faster processing
        width, height = img.size
        max_dimension = 300  # Set a maximum dimension for processing

        if width > max_dimension or height > max_dimension:
            if width > height:
                new_width = max_dimension
                new_height = int(height * (max_dimension / width))
            else:
                new_height = max_dimension
                new_width = int(width * (max_dimension / height))
            img = img.resize((new_width, new_height), Image.LANCZOS)

        # Extract colors with tolerance
        colors_result = extcolors.extract_from_image(img, tolerance=20, limit=n_colors)

        # Format results
        colors = []
        total_pixels = colors_result[1]

        for color_data in colors_result[0]:
            color = color_data[0]  # RGB tuple
            count = color_data[1]  # Pixel count

            if count / total_pixels > 0.03:  # Reduced threshold to capture more nuanced colors
                colors.append((color, count))

        # Sort and extract colors
        colors.sort(key=lambda x: x[1], reverse=True)
        sorted_colors = [color[0] for color in colors]

        # Handle edge cases
        if not sorted_colors:
            return [(0, 0, 0)] * n_colors
        while len(sorted_colors) < n_colors:
            sorted_colors.append((0, 0, 0))

        return sorted_colors[:n_colors]

    except Exception as e:
        print(f"Error processing {os.path.basename(image_path)}: {e}")
        return [(0, 0, 0)] * n_colors

def display_color_palette(colors):
    """Display a horizontal color palette (simplified)"""
    height = 50
    width = 100
    palette = np.zeros((height, width * len(colors), 3), dtype=np.uint8)

    for i, color in enumerate(colors):
        palette[:, i*width:(i+1)*width] = color

    plt.figure(figsize=(10, 2))
    plt.imshow(palette)
    plt.axis('off')

    # Add color names
    for i, color in enumerate(colors):
        color_name = closest_color(color)
        plt.text(i*width + width//2, height + 5, color_name,
                horizontalalignment='center',
                color='black')

    plt.tight_layout()
    plt.show()

def analyze_all_images():
    """Process all images and create dataset (optimized)"""
    print("Analyzing Salvador Dali paintings...")

    if not os.path.exists(IMAGE_FOLDER):
        print(f"Error: Folder {IMAGE_FOLDER} not found")
        return pd.DataFrame()

    image_files = [f for f in os.listdir(IMAGE_FOLDER)
                  if f.lower().endswith(('.jpg', '.jpeg', '.png'))]

    if not image_files:
        print(f"No image files found in {IMAGE_FOLDER}")
        return pd.DataFrame()

    total_images = len(image_files)
    print(f"Processing {total_images} paintings...")

    data = []
    for i, img_name in enumerate(image_files):
        # Show progress
        if i % 5 == 0 or i == total_images - 1:
            print(f"Progress: {i+1}/{total_images} paintings ({(i+1)/total_images*100:.1f}%)")

        path = os.path.join(IMAGE_FOLDER, img_name)

        # Extract painting name from filename
        painting_name = os.path.splitext(img_name)[0].replace('_', ' ').title()

        # Get dominant colors - using only extcolors method for speed
        dom_colors = get_colors_with_extcolors(path)
        color_names = [closest_color(tuple(c)) for c in dom_colors]

        # Calculate percentages (simplified)
        percentages = [100 // len(dom_colors)] * len(dom_colors)

        data.append({
            'image': img_name,
            'painting': painting_name,
            'year': extract_year(painting_name),  # Try to extract year if available in title
            'dominant_color': color_names[0] if color_names else "unknown",
            'palette': ', '.join(color_names),
            'color_percentages': str(percentages),
            'rgb_values': str([tuple(c) for c in dom_colors])
        })

    df = pd.DataFrame(data)

    # Save to CSV
    if len(df) > 0:
        df.to_csv(OUTPUT_CSV, index=False)
        print(f"Data saved to {OUTPUT_CSV}")

    return df

def extract_year(painting_name):
    """Try to extract year from painting name if present"""
    import re
    year_match = re.search(r'\b(18|19|20)\d{2}\b', painting_name)
    if year_match:
        return year_match.group(0)
    return "Unknown"

def plot_color_distribution(df, limit=15):
    """Visualize color distribution (top colors only)"""
    plt.figure(figsize=(12, 7))

    # Use actual colors for the bars, but limit to top 15 for readability
    color_counts = df['dominant_color'].value_counts().head(limit)

    # Get RGB values for each color name
    bar_colors = [CSS3_COLORS.get(color, (128, 128, 128)) for color in color_counts.index]
    # Normalize RGB values for matplotlib
    bar_colors = [(r/255, g/255, b/255) for r, g, b in bar_colors]

    # Create bar plot
    ax = sns.barplot(x=color_counts.values, y=color_counts.index, palette=bar_colors)

    plt.title('Dominant Colors in Salvador Dali\'s Paintings', fontsize=16)
    plt.xlabel('Number of Paintings', fontsize=12)
    plt.ylabel('Color', fontsize=12)

    # Add count labels to bars
    for i, v in enumerate(color_counts.values):
        ax.text(v + 0.1, i, str(v), va='center')

    plt.tight_layout()
    plt.show()

    # Optional: Plot color distribution over time if years are available
    if 'year' in df.columns and df['year'].nunique() > 3:
        # Group by decade if enough data
        df['decade'] = df['year'].apply(lambda y: str(y)[:3] + '0s' if y != 'Unknown' else 'Unknown')

        plt.figure(figsize=(14, 8))
        decades = df['decade'].unique()

        # Count color occurrences by decade
        decade_colors = {}
        for decade in decades:
            if decade != 'Unknown':
                decade_df = df[df['decade'] == decade]
                decade_colors[decade] = decade_df['dominant_color'].value_counts().head(5)

        # Plot if we have enough data
        if len(decade_colors) >= 3:
            # Plot evolution of color usage over time
            plt.figure(figsize=(12, 8))

            # Get top colors across all decades
            all_colors = pd.concat([counts for counts in decade_colors.values()])
            top_colors = all_colors.index.unique()[:8]  # Limit to top 8 colors

            for color in top_colors:
                data_points = []
                for decade in sorted(decade_colors.keys()):
                    counts = decade_colors[decade]
                    count = counts.get(color, 0)
                    data_points.append((decade, count))

                decades_list, counts_list = zip(*data_points)
                plt.plot(decades_list, counts_list, marker='o', linewidth=2, label=color)

            plt.title('Evolution of Dali\'s Color Palette Over Time', fontsize=16)
            plt.xlabel('Decade', fontsize=12)
            plt.ylabel('Number of Paintings', fontsize=12)
            plt.legend(title='Colors')
            plt.grid(True, alpha=0.3)
            plt.tight_layout()
            plt.show()

def find_painting(df, name):
    """Find and analyze a specific painting with enhanced visuals"""
    # Case-insensitive partial matching
    matches = df[df['painting'].str.lower().str.contains(name.lower())]

    if len(matches) == 0:
        print(f"Painting with name containing '{name}' not found in the collection!")
        return

    # If multiple matches, list them and let user select
    if len(matches) > 1:
        print(f"Found {len(matches)} paintings matching '{name}':")
        for i, painting in enumerate(matches['painting']):
            print(f"{i+1}. {painting}")

        try:
            selection = int(input("Enter number to select a painting (or 0 to cancel): ")) - 1
            if selection < 0 or selection >= len(matches):
                return
            painting = matches.iloc[selection]
        except:
            print("Invalid selection")
            return
    else:
        painting = matches.iloc[0]

    # Create a more visually pleasing display
    plt.figure(figsize=(16, 10))

    # Try to display the original painting
    try:
        img_path = os.path.join(IMAGE_FOLDER, painting['image'])
        img = Image.open(img_path)

        # Create grid layout
        plt.subplot(2, 1, 1)
        plt.imshow(np.array(img))
        plt.title(f'{painting["painting"]}', fontsize=16)
        if painting['year'] != 'Unknown':
            plt.suptitle(f'Year: {painting["year"]}', fontsize=12, y=0.95)
        plt.axis('off')
    except Exception as e:
        print(f"Could not display original painting: {e}")

    # Display color palette with percentages
    colors_rgb = eval(painting['rgb_values'])
    color_names = [closest_color(tuple(c)) for c in colors_rgb]

    plt.subplot(2, 1, 2)

    # Calculate actual color percentages
    try:
        img = Image.open(img_path).convert("RGB")
        colors_result = extcolors.extract_from_image(img, tolerance=20, limit=10)
        total_pixels = colors_result[1]
        percentages = []

        for i, color in enumerate(colors_rgb[:5]):  # Get percentages for top 5 colors
            # Find closest match in extcolors result
            min_distance = float('inf')
            found_count = 0

            for ext_color, count in colors_result[0]:
                # Calculate color distance
                distance = sum(abs(a-b) for a, b in zip(color, ext_color))
                if distance < min_distance:
                    min_distance = distance
                    found_count = count

            percentages.append(round((found_count / total_pixels) * 100, 1))
    except:
        # Fallback if we can't calculate actual percentages
        percentages = [20, 16, 13, 10, 8][:len(colors_rgb)]

    # Create enhanced color palette visualization
    height = 100
    width = 100
    num_colors = len(colors_rgb)
    palette = np.zeros((height, width * num_colors, 3), dtype=np.uint8)

    for i, color in enumerate(colors_rgb):
        palette[:, i*width:(i+1)*width] = color

        # Add color name and percentage
        color_name = color_names[i]
        percentage = percentages[i] if i < len(percentages) else 0

        plt.text(i*width + width//2, height//3, color_name,
                horizontalalignment='center',
                verticalalignment='center',
                color='white' if sum(color) < 380 else 'black',
                fontweight='bold',
                fontsize=10)

        plt.text(i*width + width//2, height*2//3, f"{percentage}%",
                horizontalalignment='center',
                verticalalignment='center',
                color='white' if sum(color) < 380 else 'black',
                fontsize=12)

    plt.imshow(palette)
    plt.title('Color Analysis', fontsize=14)
    plt.axis('off')

    # Print detailed color information
    print(f"\n'{painting['painting']}' Color Analysis:")
    if painting['year'] != 'Unknown':
        print(f"Year: {painting['year']}")
    print(f"Dominant color: {painting['dominant_color']} ({percentages[0]}%)")
    print("\nColor palette:")
    for i, color in enumerate(color_names):
        if i < len(percentages):
            print(f"  {color}: {percentages[i]}%")
        else:
            print(f"  {color}")

    # Make the layout tight and show the plot
    plt.tight_layout()
    plt.subplots_adjust(hspace=0.3)
    plt.show()

    # Additional artistic color analysis
    print("\nArtistic Color Harmony:")
    has_complementary = False
    has_analogous = False
    color_temp = "mixed"

    # Check for warm colors
    warm_colors = ["red", "orange", "yellow", "gold", "crimson", "vermilion", "amber", "cadmium red",
                  "cadmium yellow", "burnt sienna", "terracotta", "burgundy"]
    # Check for cool colors
    cool_colors = ["blue", "green", "purple", "teal", "aqua", "navy", "cerulean", "cobalt",
                  "ultramarine", "viridian", "prussian blue", "paynes gray"]

    warm_count = sum(1 for c in color_names if c in warm_colors)
    cool_count = sum(1 for c in color_names if c in cool_colors)

    if warm_count > cool_count*2:
        color_temp = "predominantly warm"
    elif cool_count > warm_count*2:
        color_temp = "predominantly cool"
    elif warm_count > cool_count:
        color_temp = "warm with cool accents"
    elif cool_count > warm_count:
        color_temp = "cool with warm accents"

    # Check for complementary colors
    complementary_pairs = [
        {"red", "green"}, {"blue", "orange"}, {"yellow", "purple"},
        {"cobalt", "cadmium yellow"}, {"ultramarine", "cadmium red"}
    ]

    color_set = set(color_names)
    for pair in complementary_pairs:
        if len(pair.intersection(color_set)) > 1:
            has_complementary = True
            break

    # Check for analogous colors
    analogous_groups = [
        {"red", "orange", "yellow"}, {"yellow", "green", "lime"},
        {"green", "teal", "blue"}, {"blue", "purple", "magenta"},
        {"purple", "magenta", "red"}
    ]

    for group in analogous_groups:
        if len(group.intersection(color_set)) > 1:
            has_analogous = True
            break

    print(f"Color temperature: {color_temp}")
    if has_complementary:
        print("Contains complementary colors (high contrast)")
    if has_analogous:
        print("Contains analogous colors (harmonious)")

    # Mood/emotional association based on color theory
    mood = []
    if "red" in color_set or "crimson" in color_set or "burgundy" in color_set:
        mood.append("passion/intensity")
    if "blue" in color_set or "navy" in color_set:
        mood.append("calmness/melancholy")
    if "yellow" in color_set or "gold" in color_set:
        mood.append("joy/energy")
    if "black" in color_set:
        mood.append("mystery/sophistication")
    if "white" in color_set or "ivory" in color_set:
        mood.append("purity/emptiness")
    if "green" in color_set:
        mood.append("nature/growth")
    if "purple" in color_set or "magenta" in color_set:
        mood.append("spirituality/luxury")

    if mood:
        print(f"Emotional associations: {', '.join(mood)}")

    return painting
def main():
    """Main function with automatic color distribution display"""
    print("Salvador Dali Paintings Color Analysis")
    print("-------------------------------------")

    # Check if data already exists to avoid reprocessing
    if os.path.exists(OUTPUT_CSV):
        print(f"Loading existing data from {OUTPUT_CSV}")
        df = pd.read_csv(OUTPUT_CSV)
    else:
        # Analyze all images
        df = analyze_all_images()

    if len(df) == 0:
        print("No data to analyze. Please check your image folder.")
        return

    # Show abbreviated list of paintings for reference
    print("\nAvailable paintings (showing first 10):")
    print(", ".join(df['painting'].head(10).tolist()))
    print(f"...and {len(df) - 10} more")

    # Automatically show color distribution without asking
    print("\nOverall Color Distribution in Dali's Works:")
    plot_color_distribution(df)

    # Additional insights about Dali's color use
    print("\nDali's Color Palette Insights:")
    dominant_colors = df['dominant_color'].value_counts()
    total_paintings = len(df)

    print(f"• Most used dominant color: {dominant_colors.index[0]} ({dominant_colors.iloc[0]} paintings, {dominant_colors.iloc[0]/total_paintings*100:.1f}%)")
    print(f"• Second most used color: {dominant_colors.index[1]} ({dominant_colors.iloc[1]} paintings, {dominant_colors.iloc[1]/total_paintings*100:.1f}%)")
    print(f"• Third most used color: {dominant_colors.index[2]} ({dominant_colors.iloc[2]} paintings, {dominant_colors.iloc[2]/total_paintings*100:.1f}%)")

    # Calculate color diversity
    total_unique_colors = len(set(','.join(df['palette']).split(', ')))
    print(f"• Color diversity: {total_unique_colors} unique colors across all paintings")

    # Simple interactive painting search
    while True:
        name = input("\nEnter painting name (or 'exit' to quit): ")
        if name.lower() == 'exit':
            break

        plt.close('all')  # Clear previous plots
        find_painting(df, name)

if __name__ == "__main__":
    main()